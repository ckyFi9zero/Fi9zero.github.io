<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于Markdown的基本语法</title>
      <link href="/2022/12/29/%E5%85%B3%E4%BA%8EMarkdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/12/29/%E5%85%B3%E4%BA%8EMarkdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>常用语法</h1><h2 id="标题">标题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><h2 id="字体">字体</h2><p><em>倾斜</em><br><em>倾斜</em><br><strong>加粗</strong><br><em><strong>倾斜加粗</strong></em><br><s>删除</s></p><h2 id="图片">图片</h2><p><img src="https://cdn.staticaly.com/gh/ckyFi9zero/pic_bed1@main/pic_bed/QQ%E5%9B%BE%E7%89%8720221229124537.68m6bxzvj4g0.webp" alt="图片描述" title="title"></p><h2 id="下划线">下划线</h2><hr><hr><hr><h2 id="行内式">行内式</h2><p><code>__main__</code></p><h2 id="HTML表格">HTML表格</h2><table><tr><th rowspan="2">值班人员</th><th>星期一</th><th>星期二</th><th>星期三</th></tr><tr><td>李强</td><td>张明</td><td>王平<td></tr></table><h2 id="引用">引用</h2><blockquote><p>文字<br>文字</p><p>文字<br>文字</p></blockquote><blockquote><blockquote><blockquote><p>引用1<br>引用2<br>引用3</p></blockquote></blockquote></blockquote><h2 id="列表">列表</h2><ul><li>列表文字</li></ul><ul><li>列表文字</li></ul><ul><li>列表文字</li></ul><ol><li>有序列表</li><li>有序列表</li></ol><h2 id="表格">表格</h2><table><thead><tr><th>学号</th><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>小明</td><td>男</td><td>75</td></tr><tr><td>小红</td><td>女</td><td>79</td></tr><tr><td>小陆</td><td>男</td><td>90</td></tr></tbody></table><h2 id="特殊符号">特殊符号</h2><p>\<br>*<br>{}</p><h2 id="Unicode字符">Unicode字符</h2><p>❤<br>✓<br>☀<br>★<br>☂<br>☯<br>☢<br>☎<br>∞<br>❄<br>♫<br>字符对应Unicode码<a href="https://unicode-table.com/cn/">https://unicode-table.com/cn/</a></p><h2 id="HTML">HTML</h2><p><font face="黑体">黑体</font><br><font color=#0099ff size=7 face="黑体">color=#0099ff size=7 face=“黑体”</font><br>size:规定文本的尺寸大小。可能的值:从1到7的数字。浏览器默认值是3。</p><h2 id="注脚">注脚</h2><p>使用Markdown[^1]可以效率的书写文档<br>[^1]Markdown是一种纯文本标记语言</p><h2 id="背景色">背景色</h2><table><tr><td bgcolor=orange>背景色是:orange</td></tr></table><h2 id="emjoy">emjoy</h2><p>😄<br>😃<br>😏<br>😟<br>😑</p><h2 id="数学公式">数学公式</h2><p>$$<br>\sqrt{x^{2}}<br>$$</p><p>$$<br>x+y=z<br>\tag{1}<br>$$</p><h2 id="流程图">流程图</h2><div id="flowchart-0" class="flow-chart"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: startop1=>operation: my operationc=>condition: Yes or NOe=>end: endst(right)->op1(right)->cc(yes,right)->ec(no,top)->op1</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遍历文件夹并保存</title>
      <link href="/2022/12/28/%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E5%A4%B9%E5%B9%B6%E4%BF%9D%E5%AD%98/"/>
      <url>/2022/12/28/%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E5%A4%B9%E5%B9%B6%E4%BF%9D%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1>代码</h1><h2 id="导入os包">导入os包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure><h2 id="遍历文件夹">遍历文件夹</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">data_path = <span class="string">&quot;&quot;</span> <span class="comment">#需要遍历的文件夹名</span></span><br><span class="line">img_list = os.listdir(data_path)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(img_list) == <span class="number">0</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Data directory is empty.&#x27;</span>)</span><br><span class="line">exit()</span><br><span class="line">    <span class="keyword">for</span> img_name <span class="keyword">in</span> img_list:</span><br><span class="line">        img = cv2.imread(os.path.join(data_path, img_name)) <span class="comment">#之后可以对文件夹中的图片进行形态学操作</span></span><br></pre></td></tr></table></figure><h2 id="将处理后的图片保存到指定文件夹">将处理后的图片保存到指定文件夹</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">&#x27;&#x27;</span> + <span class="string">&quot;\\&quot;</span> + img_name, result) <span class="comment">#放入for循环中</span></span><br></pre></td></tr></table></figure><h1>后话</h1><p>这里只是简单记录一个实用工具，相信之后肯定会用到很多遍历文件夹的项目。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过连接去雾代码遇到一些问题的理解</title>
      <link href="/2022/12/27/%E9%80%9A%E8%BF%87%E8%BF%9E%E6%8E%A5%E5%8E%BB%E9%9B%BE%E4%BB%A3%E7%A0%81%E9%81%87%E5%88%B0%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2022/12/27/%E9%80%9A%E8%BF%87%E8%BF%9E%E6%8E%A5%E5%8E%BB%E9%9B%BE%E4%BB%A3%E7%A0%81%E9%81%87%E5%88%B0%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1>动机</h1><p>最近因为自己给自己定的<s>ddl</s>要到了，于是疯狂肝代码。<br>我主要是做去雾方向，最近因为要用于论文，需要桥梁来和基于语义分割的复杂地貌识别算法相结合。因为深度学习的框架已经基本定在那里了，所以我只好从各种去雾方法的代码上动刀。</p><h1>源代码</h1><h2 id="ACE去雾算法（example）">ACE去雾算法（example）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线性拉伸处理</span></span><br><span class="line"><span class="comment"># 去掉最大最小0.5%的像素值 线性拉伸至[0,1]</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stretchImage</span>(<span class="params">data, s=<span class="number">0.005</span>, bins=<span class="number">2000</span></span>):</span><br><span class="line">    ht = np.histogram(data, bins);</span><br><span class="line">    d = np.cumsum(ht[<span class="number">0</span>]) / <span class="built_in">float</span>(data.size)</span><br><span class="line">    lmin = <span class="number">0</span>;</span><br><span class="line">    lmax = bins - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lmin &lt; bins:</span><br><span class="line">        <span class="keyword">if</span> d[lmin] &gt;= s:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        lmin += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lmax &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> d[lmax] &lt;= <span class="number">1</span> - s:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        lmax -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> np.clip((data - ht[<span class="number">1</span>][lmin]) / (ht[<span class="number">1</span>][lmax] - ht[<span class="number">1</span>][lmin]), <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据半径计算权重参数矩阵</span></span><br><span class="line">g_para = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getPara</span>(<span class="params">radius=<span class="number">5</span></span>):</span><br><span class="line">    <span class="keyword">global</span> g_para</span><br><span class="line">    m = g_para.get(radius, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line">    size = radius * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    m = np.zeros((size, size))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(-radius, radius + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(-radius, radius + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> h == <span class="number">0</span> <span class="keyword">and</span> w == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            m[radius + h, radius + w] = <span class="number">1.0</span> / math.sqrt(h ** <span class="number">2</span> + w ** <span class="number">2</span>)</span><br><span class="line">    m /= m.<span class="built_in">sum</span>()</span><br><span class="line">    g_para[radius] = m</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常规的ACE实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zmIce</span>(<span class="params">I, ratio=<span class="number">4</span>, radius=<span class="number">300</span></span>):</span><br><span class="line">    para = getPara(radius)</span><br><span class="line">    height, width = I.shape</span><br><span class="line">    zh = []</span><br><span class="line">    zw = []</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; radius:</span><br><span class="line">        zh.append(<span class="number">0</span>)</span><br><span class="line">        zw.append(<span class="number">0</span>)</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        zh.append(n)</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">        zw.append(n)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; radius:</span><br><span class="line">        zh.append(height - <span class="number">1</span>)</span><br><span class="line">        zw.append(width - <span class="number">1</span>)</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    <span class="comment"># print(zh)</span></span><br><span class="line">    <span class="comment"># print(zw)</span></span><br><span class="line"></span><br><span class="line">    Z = I[np.ix_(zh, zw)]</span><br><span class="line">    res = np.zeros(I.shape)</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(radius * <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(radius * <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> para[h][w] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res += (para[h][w] * np.clip((I - Z[h:h + height, w:w + width]) * ratio, -<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单通道ACE快速增强实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zmIceFast</span>(<span class="params">I, ratio, radius</span>):</span><br><span class="line">    <span class="built_in">print</span>(I)</span><br><span class="line">    height, width = I.shape[:<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">min</span>(height, width) &lt;= <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> np.zeros(I.shape) + <span class="number">0.5</span></span><br><span class="line">    Rs = cv2.resize(I, (<span class="built_in">int</span>((width + <span class="number">1</span>) / <span class="number">2</span>), <span class="built_in">int</span>((height + <span class="number">1</span>) / <span class="number">2</span>)))</span><br><span class="line">    Rf = zmIceFast(Rs, ratio, radius)  <span class="comment"># 递归调用</span></span><br><span class="line">    Rf = cv2.resize(Rf, (width, height))</span><br><span class="line">    Rs = cv2.resize(Rs, (width, height))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Rf + zmIce(I, ratio, radius) - zmIce(Rs, ratio, radius)</span><br><span class="line"></span><br><span class="line"><span class="comment"># rgb三通道分别增强 ratio是对比度增强因子 radius是卷积模板半径</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zmIceColor</span>(<span class="params">I, ratio=<span class="number">4</span>, radius=<span class="number">3</span></span>):</span><br><span class="line">    res = np.zeros(I.shape)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        res[:, :, k] = stretchImage(zmIceFast(I[:, :, k], ratio, radius))</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="深度学习predict输入模块">深度学习predict输入模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">image = Image.<span class="built_in">open</span>(img)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Open Error! Try again!&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">r_image = deeplab.detect_image(image, count=count, name_classes=name_classes)</span><br><span class="line">r_image.show()</span><br></pre></td></tr></table></figure><h2 id="谈谈想法">谈谈想法</h2><h3 id="import所有def">import所有def</h3><p>以ACE算法为例，所使用的方法层层递进，互相嵌套。以方法为单位将所有方法import非常不现实，如果将所有方法放入导包代码之下，又显得深度学习的predict代码不美观也不传统~~（就是看着很不爽）~~。并且假设再增添一种去雾算法，方法会越积越多，但却做不到每个方法都用到，其所谓树大有枯枝。</p><h3 id="import-os包先运行ACE-py">import <a href="http://xn--osACE-hk5hy7hsr9mzeo.py">os包先运行ACE.py</a></h3><p>那我不去改动代码，直接先运行不就完了。想法很美好，现实很骨感。可以通过深度学习输入部分可以看出，我们是要在运行此文件后，在运行输入图片路径。我们需要在此时将这张图片进行去雾处理，再输出来再往下运行。目前我无法想出将输入图片作为输入变量导入ACE.py运行的方法，所以也以失败告终。</p><h3 id="将所有def打包成class一起import">将所有def打包成class一起import</h3><p>想到这步已经是用了一天半了，因为也不知道可不可行，一直想先用第一种思路做一个solution出来，所以耽误了很多时间。但事实证明这种想法可行且很对。</p><h1>问题总结</h1><h2 id="关于python中类的理解">关于python中类的理解</h2><ul><li>类(Class)：用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li>方法：类中定义的函数。</li><li>类的构造方法__init__()：类有一个名为 init() 的特殊方法（构造方法），该方法在类实例化时会自动调用。</li><li>实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li><li>实例化：创建一个类的实例，类的具体对象。</li><li>继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。</li></ul><p>话不多说，直接上代码！！！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HazeRemoval1</span>: <span class="comment">#我自己定义的类名</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,filename</span>):</span><br><span class="line">        self.filename = filename</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stretchImage</span>(<span class="params">self, data, s=<span class="number">0.005</span>, bins=<span class="number">2000</span></span>):</span><br><span class="line">        ht = np.histogram(data, bins);</span><br><span class="line">        d = np.cumsum(ht[<span class="number">0</span>]) / <span class="built_in">float</span>(data.size)</span><br><span class="line">        lmin = <span class="number">0</span>;</span><br><span class="line">        lmax = bins - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> lmin &lt; bins:</span><br><span class="line">            <span class="keyword">if</span> d[lmin] &gt;= s:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            lmin += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> lmax &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> d[lmax] &lt;= <span class="number">1</span> - s:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            lmax -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> np.clip((data - ht[<span class="number">1</span>][lmin]) / (ht[<span class="number">1</span>][lmax] - ht[<span class="number">1</span>][lmin]), <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getPara</span>(<span class="params">self, radius=<span class="number">5</span></span>):</span><br><span class="line">        <span class="keyword">global</span> g_para</span><br><span class="line">        g_para = &#123;&#125;</span><br><span class="line">        m = g_para.get(radius, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> m</span><br><span class="line">        size = radius * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        m = np.zeros((size, size))</span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(-radius, radius + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(-radius, radius + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> h == <span class="number">0</span> <span class="keyword">and</span> w == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                m[radius + h, radius + w] = <span class="number">1.0</span> / math.sqrt(h ** <span class="number">2</span> + w ** <span class="number">2</span>)</span><br><span class="line">        m /= m.<span class="built_in">sum</span>()</span><br><span class="line">        g_para[radius] = m</span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">zmIce</span>(<span class="params">self, I, ratio=<span class="number">4</span>, radius=<span class="number">300</span></span>):</span><br><span class="line">        para = self.getPara(radius)</span><br><span class="line">        height, width = I.shape</span><br><span class="line">        zh = []</span><br><span class="line">        zw = []</span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n &lt; radius:</span><br><span class="line">            zh.append(<span class="number">0</span>)</span><br><span class="line">            zw.append(<span class="number">0</span>)</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">            zh.append(n)</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            zw.append(n)</span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n &lt; radius:</span><br><span class="line">            zh.append(height - <span class="number">1</span>)</span><br><span class="line">            zw.append(width - <span class="number">1</span>)</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">        <span class="comment"># print(zh)</span></span><br><span class="line">        <span class="comment"># print(zw)</span></span><br><span class="line"></span><br><span class="line">        Z = I[np.ix_(zh, zw)]</span><br><span class="line">        res = np.zeros(I.shape)</span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(radius * <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(radius * <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> para[h][w] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                res += (para[h][w] * np.clip((I - Z[h:h + height, w:w + width]) * ratio, -<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">zmIceFast</span>(<span class="params">self, I, ratio, radius</span>):</span><br><span class="line">        <span class="comment"># print(I)</span></span><br><span class="line">        height, width = I.shape[:<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">min</span>(height, width) &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> np.zeros(I.shape) + <span class="number">0.5</span></span><br><span class="line">        Rs = cv2.resize(I, (<span class="built_in">int</span>((width + <span class="number">1</span>) / <span class="number">2</span>), <span class="built_in">int</span>((height + <span class="number">1</span>) / <span class="number">2</span>)))</span><br><span class="line">        Rf = self.zmIceFast(Rs, ratio, radius)</span><br><span class="line">        Rf = cv2.resize(Rf, (width, height))</span><br><span class="line">        Rs = cv2.resize(Rs, (width, height))</span><br><span class="line">        <span class="keyword">return</span> Rf + self.zmIce(I, ratio, radius) - self.zmIce(Rs, ratio, radius)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">zmIceColor</span>(<span class="params">self, I , ratio=<span class="number">4</span>, radius=<span class="number">3</span></span>):</span><br><span class="line">        res = np.zeros(I.shape)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            res[:, :, k] = self.stretchImage(self.zmIceFast(I[:, :, k], ratio, radius))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>重点在于对self的理解，我一开始认为是具体变量，误认为是每个def中输入的变量，把方法中的I之类的替换为self，那就大错特错了。它会直接给你报大大的错（由于是嵌套方法，上一个方法返回的变量个数与下一个方法输入变量不匹配）。因为self不是实际意义上的变量，是你的实参，后面的所有方法都和它有关，但它不占用方法中的变量坑位。self可以理解为一个字典变量，内部存的就是对象的数据属性。</p><h2 id="图片PIL与cv类型的转换">图片PIL与cv类型的转换</h2><p>但是新的问题又出现了，predict中输入是用PIL中的open，得到的是图片的PIL的类型。而我们的各种opencv的形态学操作都是用图片的cv类型。因此我们在传入class后先要把图片从PIL类型转变为cv类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">PIL2cv</span>(<span class="params">self</span>): </span><br><span class="line">    image_PIL = Image.<span class="built_in">open</span>(self.filename)</span><br><span class="line">    image_cv = cv2.cvtColor(np.asarray(image_PIL), cv2.COLOR_RGB2BGR)</span><br><span class="line">    <span class="keyword">return</span> image_cv</span><br></pre></td></tr></table></figure><p>同样的，进行去雾操作后的输出图片也是cv类型，而最后也要转变为PIL类型。<br>又一个大大大坑，float,double等类型的图片不能直接用fromarray转换为PIL类型。<br>不然会报以下cv2.error错误。<br><img src="https://cdn.staticaly.com/gh/ckyFi9zero/pic_bed1@main/pic_bed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221228004827.4wmq1ikt1860.webp" alt="cv2.error"><br>所以中间要加一步astype把浮点变为整型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">self = HazeRemoval1(img)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Open Error! Try again!&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">img = self.PIL2cv()</span><br><span class="line">result = self.zmIceColor(img / <span class="number">255.0</span>) * <span class="number">255</span> <span class="comment">#算法需要，得将img像素值缩到[0,1],去雾完后再括回[0,255]</span></span><br><span class="line">image_uint8 = result.astype(np.uint8)</span><br><span class="line">image = Image.fromarray(cv2.cvtColor(image_uint8, cv2.COLOR_BGR2RGB))</span><br><span class="line">r_image = deeplab.detect_image(image, count=count, name_classes=name_classes)</span><br><span class="line">r_image.show()</span><br></pre></td></tr></table></figure><h2 id="同一张图片imshow和imwrite却不同">同一张图片imshow和imwrite却不同</h2><p>还有一个意外发现，就是imshow显示出的图片和imwrite保存的图片不一样。</p><ul><li>（1）当输入矩阵是uint8类型的时候，此时imshow显示图像的时候，会认为输入矩阵的范围在0-255之间。</li><li>（2）如果imshow的参数是double类型的时候，那么imshow会认为输入矩阵的范围在0-1。<br><img src="https://cdn.staticaly.com/gh/ckyFi9zero/pic_bed1@main/pic_bed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221228013015.6amcllg8zk00.webp" alt="imshow"></li></ul><center>imshow</center><p><img src="https://cdn.staticaly.com/gh/ckyFi9zero/pic_bed1@main/pic_bed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221228013021.254b2jzmrops.webp" alt="imwrite"></p><center>imwrite</center>是因为图片在进行一系列的对数组操作后数组已经变成了float类型，之后再对数组进行imshow时便会出现上面的第二种情况。但是图像矩阵（double型）的矩阵元素不在0-1之间，那么imshow会把超过1的元素都显示为白色。因为所输入的double的矩阵（未归一化）并不能保证元素范围在0-1之间。解决方法就是先<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image_uint8 = image_double.astype(np.uint8)</span><br></pre></td></tr></table></figure><p>再进行imshow。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 去雾 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>故事的开始</title>
      <link href="/2022/12/27/%E6%95%85%E4%BA%8B%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
      <url>/2022/12/27/%E6%95%85%E4%BA%8B%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<h1>故事开始啦</h1><p>从建站到购买域名再到现在正式开放应该差不多两周时间吧，其中参考了很多大佬的博客。<br>非常感谢以下大佬！！！</p><h2 id="fomalhaut"><a href="https://fomal.cc/">fomalhaut</a></h2><p><img src="https://cdn.staticaly.com/gh/ckyFi9zero/pic_bed1@main/pic_bed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221227172317.1fjgzx2w7ccg.webp" alt="fomalhuat"></p><h2 id="唐志远の博客"><a href="https://tzy1997.com/">唐志远の博客</a></h2><p><img src="https://cdn.staticaly.com/gh/ckyFi9zero/pic_bed1@main/pic_bed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221227172254.3y3pp36hcfg0.webp" alt="tzy"></p><h2 id="咕咕鸽"><a href="https://guguge.top/">咕咕鸽</a></h2><p><img src="https://cdn.staticaly.com/gh/ckyFi9zero/pic_bed1@main/pic_bed/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221227172222.5z3mb0k9r000.webp" alt="guguge"></p><h1>建站后话</h1><p>接下来本站会不定期更新，关于学习笔记或是吐槽生活。<br>此外，本站目前主要功能还是以撰写文章为主，评论等等其他功能会慢慢开放。<br>致敬我的第一篇博客啊哈哈哈哈哈哈!</p>]]></content>
      
      
      <categories>
          
          <category> 聊聊生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
